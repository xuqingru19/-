//树 的定义 
//广义表表示法可以表示树，或者用树形表示法，文恩图
//结点即指针，非空即有孩子（child），自身为家长（parent) ，家长在同一层的叫堂兄弟
//祖先 子孙 

//结点的度：拥有的子树的数量  树的度各个结点的度的最大值
//叶子结点：度为0的结点（终端结点）
//分支结点：度大于0的结点
 
//树的宽度：统计每一层的结点数量，取最大数 
//结点之间的路径：由从一个结点到另一个结点的所径分支和结点组成
//从根到结点的路径

//结点的层次/深度： 根结点为第一层，其孩子结点的层次等于它的层次加一，若某结点在i层，则其子树的根就在第i+1层
//结点的高度：从下往上， 叶结点的高度为1，非叶结点的高度等于它的孩子结点高度中的大值加1
//树的深度==树的高度 
//但是 结点的深度 不一定等于 结点的高度 

//有序树
//无序树

//满m叉树/满m次树：除根结点和叶子结点外，其余结点度数均为m
//完全m叉树/完全m次树： 按照满m次树的层序编号后，最高层连续缺少编号最大的若干个结点，但至少有一个结点
//e.g. 完全二叉树的特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。
//森林

//二叉树 5种不同形态 
//有左右之分，即顺序不能任意颠倒
//性质1：若二叉树结点的层次从 1 开始, 则在二叉树的第 i 层(i≥1)最多有 2^(i-1) 个结点
//性质2：深度为 k( k≥1 )的二叉树最少有 k 个结点，最多有 2^k -1个结点
//性质3：（证明蛮奇妙）对任何一棵二叉树，如果其叶结点有n_0个，度为 2 的非叶结点有n_2个,   则有n_0 = n_2 ＋ 1
//性质4：二叉树的分支数等于二叉树中所有结点的度的总和

//满二叉树

//完全二叉树
//性质1：具有 n (n≥0) 个结点的完全二叉树的深度为」log_2 n」+1  
//性质2 ：若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：
//			若 i=1，则该结点是二叉树的根，无双亲；否则，编号为」iM2」 的结点为其双亲结点
//			若 2i>n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点
//			若 2i+1>n，则该结点无右孩子结点，否则，编号为2i+1 的结点为其右孩子结点

//存储：顺序存储，链式存储（二叉链表，三叉链表，线索链表）

//遍历：先左后右（先序DLR，中序LDR，后序LRD） 
//先序遍历 Preorder Traversal
Status PreorderTraverse (BiTree *T,  Status(*Visit)(TElemType e)) {
	if (T) {
      	if (Visit(T->data))            // 访问结点
         	if (PreorderTraverse (T->lchild, Visit)) //遍历左子树
             	if (PreorderTraverse (T->rchild, Visit)) //遍历右子树
             		return OK;
         		return ERROR;
	}
 	else  return OK;
}

//二叉树的创建
BiTree *CreateBiTree() {
	//按先序输入二叉树中结点的值即字符，空格或Z
	//表示空树，构造二叉链表表示的二叉树
	scanf("%c",&x);
	if (x==‘Z’) bt = NULL;
	else {
		bt=(BiTree *)malloc(sizeof(BiTree));
		if(!bt) return NULL;
	    bt->data=x; //生成根结点
	    bt->lchild =CreateBiTree(); //构造左子树
	    bt->rchild =CreateBiTree(); //构造右子树
	return bt;
}

//遍历算法的非递归描述――利用栈实现树的中序遍历
void Inorder_iter1(BiTree *T, Status (*Visit)(TElemType e)) {
	SqStack S; InitStack(&S);
	BiTree *p; p = T;
	while (p || ! StackEmpty(&S)){
       	if (p) {Push(&S, p);  p= p->lchild;} 
		//该子树沿途结点进栈
       	else { Pop (&S, &p); //退栈
            if (!Visit (p->data)) return ERROR; //访问
            p = p->rchild; //遍历指针进到右孩子
        }
	} //while
	return OK;
}
 
//层次遍历――采用队列（先进先出） 




 
